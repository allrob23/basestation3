<html>
    <head>
        <link rel="stylesheet" href="/script/leaflet.css" />
        <link rel="stylesheet" href="/script/leaflet-ruler.css" />
        <link rel="stylesheet" href="/script/leaflet-reticle.css" />
        <link rel="stylesheet" href="/script/Control.Coordinates.css" />
        <script src="/script/leaflet.js"></script>
        <script src="/script/leaflet-ruler.js"></script>
        <script src="/script/L.KML.js"></script>
        <script src="/script/Control.Coordinates.js"></script>
        <script src="/script/leaflet-reticle.js"></script>
        <script src="/script/leaflet-kmz-src.js"></script>

        <style>
            .leaflet-toggle{
              height: 35px;
              width: 35px;
              background-repeat: no-repeat;
              background-position: center;
            }
            .kml-popup .leaflet-popup-tip,
            .kml-popup table,
            .weather-popup div,
            .weather-popup .leaflet-popup-tip,
            .weather-popup .leaflet-content-wrapper .leaflet-popup-content,
            .weather-popup table,
            .kml-popup .leaflet-popup-content-wrapper {
                background: #e0e0e0;
                color: #234c5e;
                font-family: verdana, arial, tahoma, 'sans serif'; 
                font-size: 10px;
            }
        </style>
    </head>
    <body>
        <div style="width: 100vw; height: 100vh" id="map"></div>
        <script type="text/javascript">

            function formatPos(dd) {
                var deg = Math.trunc(dd);
                var min = Math.abs(dd - deg)*60;
                var zero = min < 10 ? '0' : '';
                return (deg + '&deg;' + zero + min.toFixed(3) + '&prime;');
            }

            function removeTags(str, tag) {
                const reStr = `<${tag}.*>.*?<\\\/${tag}>`;
                const re = new RegExp(reStr, 'ig');
                console.log(reStr);
                if ((str===null) || (str===''))
                    return false;
                else
                    str = str.toString();
                      
                return str.replace(re, '');
            }
            async function fetchWeather(latlng, popup, map) {
                var url1 = "https://marine-api.open-meteo.com/v1/marine?latitude=" + latlng.lat.toFixed(4) + "&longitude=" + latlng.lng.toFixed(4) + "&hourly=wave_height";
                var url2 = "https://api.open-meteo.com/v1/forecast?latitude=" + latlng.lat.toFixed(4) + "&longitude=" + latlng.lng.toFixed(4) + "&hourly=windspeed_10m,pressure_msl,precipitation,visibility";
                var url3 = `/proxy/https://api.opentopodata.org/v1/gebco2020?locations=${latlng.lat.toFixed(4)},${latlng.lng.toFixed(4)}`;
                var url5 = `/proxy/https://marine.weather.gov/MapClick.php?lat=${latlng.lat.toFixed(4)}&lon=${latlng.lng.toFixed(4)}&unit=0&lg=english&FcstType=text&TextType=1`; 
                // Promise.all does bomb if anything bombs - but is faster ...
                let resp = await Promise.all([
                                                fetch(url1).then(response => response.json()),
                                                fetch(url2).then(response => response.json()),
                                                fetch(url3).then(response => response.json()),
                                                fetch(url5).then(response => response.text()),
                                             ]);
                
                let waves = resp[0];
                let wind = resp[1];
                let depth = resp[2];
                let marine = resp[3];
                
                marine = removeTags(marine, 'head');
                marine = marine.replaceAll('MapClick.php', 'https://marine.weather.gov/MapClick.php');
                marine = marine.replaceAll('width="800"', '');
               
                var n = waves['hourly']['time'].length;
                var m = wind['hourly']['time'].length;
                var i;
                var txt = "Forecast for " + formatPos(latlng.lat) + "," + formatPos(latlng.lng) + ',z=' + depth['results'][0]['elevation'] + 'm <table style="text-align:right";>';
                
                txt += '<tr style="text-align:center;"><th>UTC</th><th>wind (m/s)</th><th>SWH (m)</th><th>SLP (mbar)</th><th>precip (mm)</th><th>vis (km)</th></tr>';
                for (i = 0 ; i < n && i < m && i < 72 ; i += 12) {
                    txt += "<tr><td>" + waves['hourly']['time'][i] + "</td>"; 
                    txt += "    <td>" + (parseFloat(wind['hourly']['windspeed_10m'][i])/3.6).toFixed(2) + "</td>";
                    txt += "    <td>" + waves['hourly']['wave_height'][i] + "</td>";
                    txt += "    <td>" + wind['hourly']['pressure_msl'][i] + "</td>";
                    txt += "    <td>" + wind['hourly']['precipitation'][i] + "</td>";
                    txt += "    <td>" + (parseFloat(wind['hourly']['visibility'][i])/1000).toFixed(0.1) + "</td></tr>";
                }
                txt += "</table>";
                txt += "via Open-Meteo and German Weather Service DWD";

                if (marine.includes("NWS Forecast for:")) {
                    txt += "<br>" + marine;
                }

                popup.setLatLng(latlng)
                     .setContent(txt)
                     .openOn(map);
            }

            async function loadGliderKML(map, urls) {
                var kml;
                var parser;

                let resp = await Promise.all(urls.map(url => fetch(url).then(res => res.text())));
                for (var i = 0 ; i < urls.length ; i++) {
                    kmltext = resp[i]; 

                    // Create new kml overlay
                    parser = new DOMParser();
                    kml = parser.parseFromString(kmltext, 'text/xml');
                    let ctr = null;
                    track = new L.KML(kml, { 
                                            iconOptions: {
                                                iconSize: [16,16],
                                            }
                                        });

                    map.addLayer(track);
                    // layerControl.addOverlay(track, "KML"); // If we add controls for the dives and targets layers
                                                              // then this "KML" control only turns off the glider.
                                                              // If we don't add controls for dives and targets
                                                              // then the "KML" control works as expected

                    for (k of Object.keys(track._layers)) {
                        if (track._layers[k].options.hasOwnProperty('id') && track._layers[k].options.id == "seagliderPositionHighlightState") {
                            ctr = track._layers[k]._latlng;
                        }
                        if (track._layers[k].options.hasOwnProperty('name') 
                            && (track._layers[k].options.name.includes('Dives') || track._layers[k].options.name.includes('Targets'))) {
                            layerControl.addOverlay(track._layers[k], track._layers[k].options.name);
                        }
                    }

                    // Adjust map to show the kml for the first glider
                    if (i == 0) {
                        const bounds = track.getBounds();
                        map.fitBounds(bounds);
                        if (ctr) map.panTo(ctr);
                    }
                }
            }
        </script>

        <script type="text/javascript">

            L.Control.toggle = L.Control.extend({
                onAdd: function(map) {
                    this._map = map;
                    this._container = L.DomUtil.create('div', 'leaflet-bar');
                    this._container.classList.add('leaflet-toggle');
                    L.DomEvent.disableClickPropagation(this._container);
                    L.DomEvent.on(this._container, 'click', this._toggleControl, this);
                    this._choice = false;
                    this._defaultCursor = this._map._container.style.cursor;
                    this._allLayers = L.layerGroup();
                    this._control = null;
                    return this._container;
                },

                onRemove: function(map) {
                    L.DomEvent.off(this._container, 'click', this._toggleControl, this);
                    // Nothing more to do here
                },
                _toggleControl: function() {
                    if (this._control.style.visibility == "visible")  
                        this._control.style.visibility = "hidden"; 
                    else 
                        this._control.style.visibility = "visible"; 

                    return false;
                },
                configure: function(control, image, state) {
                    this._control = control;
                    control.style.visibility = state ? "visible" : "hidden";
                    this._container.style.backgroundImage = 'url(' + image + ')';
                }
            });

            L.control.toggle = function(opts) {
                return new L.Control.toggle(opts);
            }


            // Make basemap
            const map = new L.Map('map', { center: new L.LatLng(47.5, -122.3), zoom: 11 });
            const osm = new L.TileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { opacity: 1.0 });
            const noaa = new L.TileLayer('https://iop.apl.washington.edu/tiles/NOAA+Stamen/{z}/{x}/{y}.png');


            gebco = L.tileLayer.wms("https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv?",
                                    {
                                        layers:"GEBCO_LATEST_2",
                                        format:"image/png",
                                        opacity: 0.4,
                                    });
                           
            map.addLayer(gebco); 
            map.addLayer(osm);
            
            // AIS
            
            ais = L.tileLayer("https://tiles.marinetraffic.com/ais_helpers/shiptilesingle.aspx?output=png&sat=1&grouping=shiptype&tile_size=512&legends=1&zoom={z}&X={x}&Y={y}",
                                    {
                                        tileSize: 512,
                                    });

            map.addLayer(ais);

            // chart marks

            chart = L.tileLayer("https://t1.openseamap.org/seamark/{z}/{x}/{y}.png", 
                                    {
                                        
                                    });

            map.addLayer(chart);

            // wind

            wind = L.tileLayer("https://tile.openweathermap.org/map/wind_new/{z}/{x}/{y}.png?appid=b20fbf5f478d03dc8fd5541f62871c40",
                                    {
                                    });

            // map.addLayer(wind); //  not on by default

            var legend = L.control({position: 'bottomright'});

            legend.onAdd = function (map) {
                console.log('adding legend');
                var div = L.DomUtil.create('div', 'wind legend');
                div.innerHTML = '<img src="/script/images/OWM_windscale.png">';
                return div;
            };

            // legend.addTo(map); // match the layer default

            // map event handlers

            //turn legend on and off as wind layer comes and goes
            map.on('overlayadd', function(evt) {
                console.log('overlayadd ' + evt.name);
                if (evt.name === 'wind') {
                    legend.addTo(this);
                }
            });
            map.on('overlayremove', function(evt) {
                console.log('overlayremove ' + evt.name);
                if (evt.name === 'wind')
                    this.removeControl(legend);
            });

            var popup = L.popup({ maxWidth:600, minWidth:400, className: 'weather-popup' });
            map.on('click', function(evt) {
                if (ruler._choice == false) {
                    console.log(evt.latlng);
                    fetchWeather(evt.latlng, popup, map);
                }
            });

            // contours
            
            contours = L.tileLayer.wms("http://www.opendem.info:80/geoserver/opendem/ows?",
                                    {
                                        format: "image/png",
                                        layers: "opendem:gebco_2021_contours",
                                        opacity: 0.2,
                                        // tileSize: 1024,
                                    });
            //  map.addLayer(contours); // not on by default
            
            // coordinate display

            L.control.coordinates({
                position:"bottomleft", //optional default "bootomright"
                decimals:2, //optional default 4
                decimalSeperator:".", //optional default "."
                labelTemplateLat:"Lat: {y}", //optional default "Lat: {y}"
                labelTemplateLng:"Lon: {x}", //optional default "Lng: {x}"
                enableUserInput:true, //optional default true
                useDMS:false, //optional default false
                useLatLngOrder: true, //ordering of labels, default false-> lng-lat
                labelFormatterLng : formatPos, //optional default none,
                labelFormatterLat : formatPos, //optional default none
            }).addTo(map);

            // ruler tool

            var options = {
                position: 'topleft',
                lengthUnit: {
                    factor: 1, // 0.539956803,    //  from km to nm
                    display: 'km',
                    decimal: 2,
                    label: 'distance'
                }
            };                               
            ruler = L.control.ruler(options);
            ruler.addTo(map);

            // reticle

            reticle = L.control.reticle({
                                            mapId: "map",
                                            metric: true,
                                            fetchElevation: false,
                                        });
            reticle.addTo(map); 
            L.control.toggle({ position: 'topleft' }).addTo(map).configure(reticle.canvas, '/script/images/reticle.png', false);
            
            // layer control

            var baseLayers = {
                "OpenSteetMap": osm,
                "NOAA+Stamen": noaa,
            }

            var overlayLayers = {
                "GEBCO": gebco,
                "contours": contours,
                "AIS": ais,
                "chart marks": chart,
                "wind": wind,
            }

            var layerControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
            

            // ice edge first

            kmz = L.kmzLayer();
            kmz.on('load', function(e) {
                layerControl.addOverlay(e.layer, e.name);
            });

            // we have to proxy these or we run into CORS problems
            kmz.load('/proxy/https://usicecenter.gov/File/DownloadCurrent?pId=14', 'Arctic ice edge');
            kmz.load('/proxy/https://usicecenter.gov/File/DownloadCurrent?pId=22', 'Antarctic ice edge');

            // KML and snap to KML

            // glider stuff

            // use the KML library vz KMZ as we've already got the plumbing
            // to get it out of the kmz via the server and that lib
            // does a better job of grouping in the layers so we can
            // turn pieces on and off

            // var glider = window.location.pathname.split('/').at(-1)
            var path = window.location.pathname.split('/');
            var first = path.indexOf('map') + 1;
            var glider = path[first];
            var urls = [];

            document.title = glider + ' - map';
            for (var i = first ; i < path.length ; i++) 
                urls.push('/kml/' + path[i]);

            loadGliderKML(map, urls);
            

        </script>
    </body>
</html>
